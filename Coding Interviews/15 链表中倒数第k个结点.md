# 链表中倒数第k个结点

>输入一个链表，输出该链表中倒数第k个结点。为了符合习惯，本题从1开始计数，即使链表的尾结点是倒数第一个结点。
例如：一个链表有6个结点，从头结点开始它们的值依次是1、2、3、4、5、6，这个链表的倒数第三个结点的值为4的节点。

## 0x01 分析

### 1.1 思路一

假设链表有n个结点，那么倒数第k个结点，就是从头结点开始的第`n - k + 1`个结点。如果我们能够得到链表中结点的个数n，那么只要从头往后走`n - k + 1`即可。
但是这样需要遍历两次数组，不是最好的实现。

### 1.2 思路二

只遍历一次就找到倒数第k个结点，可以定义两个指针。第一个指针从链表头开始向前走k - 1，第二个指针保持不动；从第k步开始，第二个指针也从链表头开始遍历，由于两个指针间的距离为k - 1，所以当第一个指针到达链表尾部时，第二个指针正好位于倒数第k个结点。

**需要注意的特殊情形**

- 链表为空时
- k = 0时
- k大于链表的长度时

## 0x02 实现

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head, int k) {
        // 当链表为空或k=0时，返回null
        if (head == null || k == 0)
            return null;
        
        ListNode ahead = head;
        ListNode behind = null;
        for (int i = 0; i < k - 1; i++) {
            // 判断链表长度是否小于k
            if (ahead.next != null) {
                ahead = ahead.next;
            } else {
                return null;
            }
        }
        
        behind = head;
        while (ahead.next != null) {
            ahead = ahead.next;
            behind = behind.next;
        }
        return behind;
    }
}
```

## 0x03 拓展

- 求链表的中间点。如果链表结点总数为奇数，则返回中间点；如果链表结点总数为偶数，则返回中间两个点中的任意一个。
为了解决此类问题，可以定义两个指针，同时从链表头结点出发，一个指针一次走一部，另一个指针一次走两步。当走的快的指针到达链表尾部时，走的慢的指针正好在链表中间。

- 判断一个单向链表是否形成了环型结构。
定义两个指针，同时从链表的头结点出发，一个指针一次走一步，另一个指针一次走两步。如果走的快的指针追上了走的慢的指针，那么链表就是环形链表；如果走的快的指针走到了链表的末尾都没有追上第一个指针，那么链表就不是环形链表。

>当我们用一个指针遍历链表不能解决问题的时候，可以尝试用两个指针来遍历链表。可以让其中一个指针的速度快一些，或者让它先在链表上走若干步。

2018-08-26 17:09:30 星期日